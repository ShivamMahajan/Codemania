What 's new ?

default_order="id desc"  Sorting in view.xml

 _order = "priority desc, sequence, date_start, name, id"  in python file.by default asc order 

<field name="limit">5</field>  in your action (XML file).

<field name="standard_id" operator="child_of" />
Using operator in search view
Using 'Child_of' operator In 'Parent-Child Relationship

Onchange :

def onchange_name(self, cr, uid, ids, name):
		return {'value': {'name': name}}
        return {}
        name is the field whose value is  changed
  <field name="name" placeholder="Task summary..." class="oe_inline" on_change="onchange_name(name)" />


uid
active_id
False
True


Priority:
<field name="priority" eval="15"/>

attrs="{'readonly':[('stage_id','!=', 9)]}"

'priority': fields.selection([('0','Low'), ('1','Normal'), ('2','High')], 'Priority', select=True),
'0' '1' '2' are unicode characters not the integer
So intialize in the form
	vals['priority']='3'
	
  def __init__(self, cr, uid, name, context):
        super(account_analytic_balance, self).__init__(cr, uid, name, context=context)
        self.localcontext.update( {
            'time': time,
            'get_objects': self._get_objects,  # Method
            })
            
A constructor is a special kind of method that Python calls when it instantiates an object using the definitions found in your class
MyInstance = MyClass()

 Python relies on the constructor to perform tasks such as initializing (assigning values to) any instance variables that the object will need when it starts. Constructors can also verify that there are enough resources for the object and perform any other start-up task you can think of.

The name of a constructor is always the same, __init__(). The constructor can accept arguments when necessary to create the object. When you create a class without a constructor, Python automatically creates a default constructor for you that doesn’t do anything. Every class must have a constructor, even if it simply relies on the default constructor. 


def init(self, cr):
        tools.drop_view_if_exists(cr, 'analytic_entries_report')
        cr.execute("""

You can create a method init(self, cr) in your model and it will be called upon module installation or upgrade. 
You can check for update or install mode by checking the the existence of data or structures that should have 
been created in initialization or you can just use common sql or replace mechanism to use the same sql for both states.

Most reports use this method to create required views


Method Overloading :
There is no function overloading in Python, meaning that you can't have multiple functions with the same name but different arguments.
Python supports overloading but in a Pythonic way. (using variable length arguments) *args




fields.property() 

'property_stock_procurement': fields.property(
        type='many2one',
        relation='stock.location',
        string="Procurement Location",
        view_load=True,
        domain=[('usage','like','procurement')],
        help="This stock location will be used, instead of the default one, as the source location for stock moves generated by procurements."),
        
        
       "The fields.property class inherits from fields.function and overrides the read and write method. 
       The type of this field is many2one, so in the form a property is represented like a many2one function. 
       But the value of a property is stored in the ir.property class/table as a complete record.
     The stored value is a field of type reference (not many2one) because each property may point to a different object. " 
     
     
     A property is a concept that is attached to an object and has special features:

    Different value for the same property depending on the company

    Rights management per field

    It's a link between resources (many2one)

So yes, it won't show in the database 'stock' table, but it will be in the ir_property table. 
This allows for different properties for the same object depending on the users current company.
There is some use cases where value of the field must change depending of the current company.

To activate such behavior you can now use the company_dependent option.

A notable evolution in new API is that “property fields” are now searchable.

class res_partner(osv.osv):
    _name = 'res.partner'
    _inherit = 'res.partner'
    _columns = {
        'property_product_pricelist': fields.property(
            type='many2one', 
            relation='product.pricelist', 
            domain=[('type','=','sale')],
            string="Sale Pricelist", 
            help="This pricelist will be used, instead of the default one, for sales to the current partner"),
    }
Name :property_product_pricelist
Field :Sale Pricelist #Field Label 
 Resource  :  Resource 
 Value :product.pricelist,6  #Object Relation 
 Type : Many2one
 
 https://www.odoo.com/es_ES/forum/ayuda-1/question/beginner-question-about-functional-fields-and-property-fields-77398#answer_77401



Default sequence for menuitem is 10 .
They are sorted on the basis of their id created
